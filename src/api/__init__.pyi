# This file is auto-generated by tools/gen_g_stubs.py. DO NOT EDIT.
# Regenerate with: python -m tools.gen_g_stubs

from typing import Any, Protocol, TypedDict, TypeAlias
from engine.core.geometry import Geometry as Geometry
from api.effects import Pipeline as Pipeline

JSONScalar: TypeAlias = int | float | str | bool | None
JSONLike: TypeAlias = JSONScalar | list['JSONLike'] | dict[str, 'JSONLike']

class PipelineSpecStep(TypedDict):
    name: str
    params: dict[str, JSONLike]

PipelineSpec: TypeAlias = list[PipelineSpecStep]

class _GShapes(Protocol):
    def asemic_glyph(self, *, region: tuple[float, float, float, float] = ..., smoothing_radius: float = ..., diacritic_probability: float = ..., diacritic_radius: float = ..., random_seed: float = ..., **_params: Any) -> Geometry:
        ...
    def attractor(self, *, attractor_type: str = ..., points: int = ..., dt: float = ..., scale: float = ..., **_params: Any) -> Geometry:
        ...
    def capsule(self, *, radius: float = ..., height: float = ..., segments: int = ..., latitude_segments: int = ..., **_params: Any) -> Geometry:
        ...
    def cone(self, *, radius: float = ..., height: float = ..., segments: int = ..., **_params: Any) -> Geometry:
        ...
    def cylinder(self, *, radius: float = ..., height: float = ..., segments: int = ..., **_params: Any) -> Geometry:
        ...
    def grid(self, *, nx: int = ..., ny: int = ..., **_params: Any) -> Geometry:
        ...
    def line(self, *, length: float = ..., angle_deg: float = ..., **_params: Any) -> Geometry:
        ...
    def lissajous(self, *, freq_x: float = ..., freq_y: float = ..., freq_z: float = ..., phase: float = ..., phase_y: float = ..., phase_z: float = ..., points: int = ..., **_params: Any) -> Geometry:
        ...
    def polygon(self, *, n_sides: int | float = ..., **_params: Any) -> Geometry:
        ...
    def polyhedron(self, *, polygon_index: int = ..., **_params: Any) -> Geometry:
        ...
    def sphere(self, *, subdivisions: int = ..., sphere_type: int = ..., mode: int = ..., **_params: Any) -> Geometry:
        ...
    def text(self, *, text: str = ..., em_size_mm: float = ..., font: str = ..., font_index: int = ..., text_align: str = ..., tracking_em: float = ..., line_height: float = ..., flatten_tol_em: float = ..., **_params: Any) -> Geometry:
        ...
    def torus(self, *, major_radius: float = ..., minor_radius: float = ..., major_segments: int = ..., minor_segments: int = ..., **_params: Any) -> Geometry:
        ...
    def empty(self) -> Geometry: ...
    def from_lines(self, lines: Any) -> Geometry: ...

from common.types import Vec3

class _PipelineBuilder(Protocol):
    # meta: auto_center (type=bool)
    # meta: pivot (type=vec3, range=[(-300.0, -300.0, -300.0), (300.0, 300.0, 300.0)])
    # meta: angles_rad (type=vec3, range=[(0, 0, 0), (6.283185307179586, 6.283185307179586, 6.283185307179586)])
    # meta: scale (type=vec3, range=[(0.25, 0.25, 0.25), (4.0, 4.0, 4.0)])
    # meta: delta (type=vec3, range=[(0, 0, 0), (200.0, 200.0, 200.0)])
    def affine(self, *, auto_center: bool = ..., pivot: Vec3 = ..., angles_rad: Vec3 = ..., scale: Vec3 = ..., delta: Vec3 = ..., **_params: Any) -> _PipelineBuilder:
        """
        スケール→回転→平行移動を適用（合成アフィン）。

        引数:
            auto_center: bool
            pivot: vec3, range [(-300.0, -300.0, -300.0), (300.0, 300.0, 300.0)]
            angles_rad: vec3, range [(0, 0, 0), (6.283185307179586, 6.283185307179586, 6.283185307179586)]
            scale: vec3, range [(0.25, 0.25, 0.25), (4.0, 4.0, 4.0)]
            delta: vec3, range [(0, 0, 0), (200.0, 200.0, 200.0)]
        """
        ...
    # meta: boldness (type=number, range=[0.0, 10.0])
    def boldify(self, *, boldness: float = ..., **_params: Any) -> _PipelineBuilder:
        """
        平行線を追加して線を太く見せる（純関数）。

        引数:
            boldness: number, range [0.0, 10.0]
        """
        ...
    # meta: draw_outline (type=boolean)
    # meta: draw_inside (type=boolean)
    def clip(self, *, outline: engine.core.geometry.Geometry | Sequence[engine.core.geometry.Geometry], draw_outline: bool = ..., draw_inside: bool = ..., **_params: Any) -> _PipelineBuilder:
        """
        閉曲線マスクで対象をクリップ（純関数）。

        引数:
            draw_outline: boolean
            draw_inside: boolean
        """
        ...
    # meta: intensity (type=number, range=[0.0, 10.0])
    # meta: subdivisions (type=integer, range=[0, 10])
    def collapse(self, *, intensity: float = ..., subdivisions: int = ..., **_params: Any) -> _PipelineBuilder:
        """
        線分を細分化してノイズで変形。

        引数:
            intensity: number, range [0.0, 10.0]
            subdivisions: integer, range [0, 10]
        """
        ...
    # meta: dash_length (type=number, range=[0.0, 100.0])
    # meta: gap_length (type=number, range=[0.0, 100.0])
    # meta: offset (type=number, range=[0.0, 100.0])
    def dash(self, *, dash_length: float | list[float] | tuple[float, ...] = ..., gap_length: float | list[float] | tuple[float, ...] = ..., offset: float | list[float] | tuple[float, ...] = ..., **_params: Any) -> _PipelineBuilder:
        """
        連続線を破線に変換。

        引数:
            dash_length: number, range [0.0, 100.0]
            gap_length: number, range [0.0, 100.0]
            offset: number, range [0.0, 100.0]
        """
        ...
    # meta: amplitude_mm (type=number, range=[(0.0, 0.0, 0.0), (50.0, 50.0, 50.0)])
    # meta: spatial_freq (type=number, range=[(0.0, 0.0, 0.0), (0.1, 0.1, 0.1)])
    # meta: t_sec (type=number, range=[0.0, 10.0])
    def displace(self, *, amplitude_mm: float | tuple[float, float, float] = ..., spatial_freq: float | tuple[float, float, float] = ..., t_sec: float = ..., **_params: Any) -> _PipelineBuilder:
        """
        3次元頂点に Perlin ノイズ変位を追加。

        引数:
            amplitude_mm: number, range [(0.0, 0.0, 0.0), (50.0, 50.0, 50.0)]
            spatial_freq: number, range [(0.0, 0.0, 0.0), (0.1, 0.1, 0.1)]
            t_sec: number, range [0.0, 10.0]
        """
        ...
    # meta: interval (type=integer, range=[1, 100])
    # meta: offset (type=integer, range=[0, 100])
    # meta: min_length (type=number, range=[0.0, 200.0])
    # meta: max_length (type=number, range=[0.0, 200.0])
    # meta: probability (type=number, range=[0.0, 1.0])
    # choices: by in ['line', 'face']
    # meta: seed (type=integer, range=[0, 2147483647])
    # choices: keep_mode in ['keep', 'drop']
    def drop(self, *, interval: int | None = ..., offset: int = ..., min_length: float | None = ..., max_length: float | None = ..., probability: float = ..., by: str = ..., seed: int | None = ..., keep_mode: str = ..., **_params: Any) -> _PipelineBuilder:
        """
        線や面を条件で間引く。

        引数:
            interval: integer, range [1, 100]
            offset: integer, range [0, 100]
            min_length: number, range [0.0, 200.0]
            max_length: number, range [0.0, 200.0]
            probability: number, range [0.0, 1.0]
            by: choices { 'line', 'face' }
            seed: integer, range [0, 2147483647]
            keep_mode: choices { 'keep', 'drop' }
        """
        ...
    # meta: factor (type=number, range=[0.0, 50.0])
    def explode(self, *, factor: float = ..., **_params: Any) -> _PipelineBuilder:
        """
        連続線を線分単位に分断し外側へずらす（全体スケールで短縮）。

        引数:
            factor: number, range [0.0, 50.0]
        """
        ...
    # meta: direction (type=vec3)
    # meta: distance (type=number, range=[0.0, 200.0])
    # meta: scale (type=number, range=[0.0, 3.0])
    # meta: subdivisions (type=integer, range=[0, 8])
    # choices: center_mode in ['origin', 'auto']
    def extrude(self, *, direction: Vec3 = ..., distance: float = ..., scale: float = ..., subdivisions: int = ..., center_mode: str = ..., **_params: Any) -> _PipelineBuilder:
        """
        2D/3Dポリラインを指定方向に押し出し、側面エッジを生成。

        引数:
            direction: vec3
            distance: number, range [0.0, 200.0]
            scale: number, range [0.0, 3.0]
            subdivisions: integer, range [0, 8]
            center_mode: choices { 'origin', 'auto' }
        """
        ...
    # meta: angle_sets (type=integer, range=[1, 6])
    # meta: angle_rad (type=number, range=[0.0, 6.283185307179586])
    # meta: density (type=number, range=[0.0, 400])
    # meta: spacing_gradient (type=number, range=[-5.0, 5.0])
    # meta: remove_boundary (type=boolean)
    def fill(self, *, angle_sets: int | list[int] | tuple[int, ...] = ..., angle_rad: float | list[float] | tuple[float, ...] = ..., density: float | list[float] | tuple[float, ...] = ..., spacing_gradient: float | list[float] | tuple[float, ...] = ..., remove_boundary: bool = ..., **_params: Any) -> _PipelineBuilder:
        """
        閉じた形状をハッチングで塗りつぶし（純関数）。

        引数:
            angle_sets: integer, range [1, 6]
            angle_rad: number, range [0.0, 6.283185307179586]
            density: number, range [0.0, 400]
            spacing_gradient: number, range [-5.0, 5.0]
            remove_boundary: boolean
        """
        ...
    # meta: n_mirror (range=[1, 8])
    # meta: cx (range=[0, 1000.0])
    # meta: cy (range=[0, 1000.0])
    # meta: show_planes (type=bool)
    def mirror(self, *, n_mirror: int = ..., cx: float = ..., cy: float = ..., source_side: bool | Sequence[bool] = ..., show_planes: bool = ..., **_params: Any) -> _PipelineBuilder:
        """
        対象面ミラーリング（n=1/2）。

        引数:
            n_mirror: range [1, 8]
            cx: range [0, 1000.0]
            cy: range [0, 1000.0]
            show_planes: bool
        """
        ...
    # meta: n_azimuth (range=[1, 64])
    # meta: cx (range=[0.0, 1000.0])
    # meta: cy (range=[0.0, 1000.0])
    # meta: cz (range=[0.0, 1000.0])
    # meta: axis (type=vec3, range=[(-1.0, -1.0, -1.0), (1.0, 1.0, 1.0)])
    # meta: phi0_deg (range=[-180.0, 180.0])
    # choices: mode in ['azimuth', 'polyhedral']
    # choices: group in ['T', 'O', 'I']
    # meta: use_reflection (type=bool)
    # meta: show_planes (type=bool)
    def mirror3d(self, *, n_azimuth: int = ..., cx: float = ..., cy: float = ..., cz: float = ..., axis: Sequence[float] = ..., phi0_deg: float = ..., mirror_equator: bool = ..., source_side: bool | Sequence[bool] = ..., mode: str = ..., group: str | None = ..., use_reflection: bool = ..., show_planes: bool = ..., **_params: Any) -> _PipelineBuilder:
        """
        3D 放射状ミラー（azimuth/ polyhedral）。

        引数:
            n_azimuth: range [1, 64]
            cx: range [0.0, 1000.0]
            cy: range [0.0, 1000.0]
            cz: range [0.0, 1000.0]
            axis: vec3, range [(-1.0, -1.0, -1.0), (1.0, 1.0, 1.0)]
            phi0_deg: range [-180.0, 180.0]
            mode: choices { 'azimuth', 'polyhedral' }
            group: choices { 'T', 'O', 'I' }
            use_reflection: bool
            show_planes: bool
        """
        ...
    # choices: join in ['mitre', 'round', 'bevel']
    # meta: segments_per_circle (type=integer, range=[1, 100])
    # meta: distance (type=number, range=[0.0, 25.0])
    # meta: keep_original (type=bool)
    def offset(self, *, join: str = ..., segments_per_circle: int = ..., distance: float = ..., keep_original: bool = ..., **_params: Any) -> _PipelineBuilder:
        """
        Shapely を用いて輪郭をオフセット（膨張/収縮）。

        引数:
            join: choices { 'mitre', 'round', 'bevel' }
            segments_per_circle: integer, range [1, 100]
            distance: number, range [0.0, 25.0]
            keep_original: bool
        """
        ...
    # meta: site_count (type=integer, range=[12, 500])
    # meta: seed (type=integer, range=[0, 2147483647])
    def partition(self, *, site_count: int = ..., seed: int = ..., **_params: Any) -> _PipelineBuilder:
        """
        平面内の領域（偶奇規則）を Voronoi で分割し閉ループ群を返す（Shapely 必須）。

        引数:
            site_count: integer, range [12, 500]
            seed: integer, range [0, 2147483647]
        """
        ...
    # meta: count (type=integer, range=[0, 100])
    # meta: cumulative_scale (type=bool)
    # meta: cumulative_offset (type=bool)
    # meta: cumulative_rotate (type=bool)
    # meta: offset (type=vec3, range=[(-300.0, -300.0, -300.0), (300.0, 300.0, 300.0)])
    # meta: angles_rad_step (type=vec3, range=[(-3.141592653589793, -3.141592653589793, -3.141592653589793), (3.141592653589793, 3.141592653589793, 3.141592653589793)])
    # meta: scale (type=vec3, range=[(0.5, 0.5, 0.5), (1.5, 1.5, 1.5)])
    # meta: curve (type=float, range=[0.1, 5.0])
    # meta: auto_center (type=bool)
    # meta: pivot (type=vec3, range=[(-300.0, -300.0, -300.0), (300.0, 300.0, 300.0)])
    def repeat(self, *, count: int = ..., cumulative_scale: bool = ..., cumulative_offset: bool = ..., cumulative_rotate: bool = ..., offset: Vec3 = ..., angles_rad_step: Vec3 = ..., scale: Vec3 = ..., curve: float = ..., auto_center: bool = ..., pivot: Vec3 = ..., **_params: Any) -> _PipelineBuilder:
        """
        入力のコピーを配列状に生成。

        引数:
            count: integer, range [0, 100]
            cumulative_scale: bool
            cumulative_offset: bool
            cumulative_rotate: bool
            offset: vec3, range [(-300.0, -300.0, -300.0), (300.0, 300.0, 300.0)]
            angles_rad_step: vec3, range [(-3.141592653589793, -3.141592653589793, -3.141592653589793), (3.141592653589793, 3.141592653589793, 3.141592653589793)]
            scale: vec3, range [(0.5, 0.5, 0.5), (1.5, 1.5, 1.5)]
            curve: float, range [0.1, 5.0]
            auto_center: bool
            pivot: vec3, range [(-300.0, -300.0, -300.0), (300.0, 300.0, 300.0)]
        """
        ...
    # meta: auto_center (type=bool)
    # meta: pivot (type=vec3, range=[(-300.0, -300.0, -300.0), (300.0, 300.0, 300.0)])
    # meta: angles_rad (type=vec3, range=[(-3.141592653589793, -3.141592653589793, -3.141592653589793), (3.141592653589793, 3.141592653589793, 3.141592653589793)])
    def rotate(self, *, auto_center: bool = ..., pivot: Vec3 = ..., angles_rad: Vec3 = ..., **_params: Any) -> _PipelineBuilder:
        """
        回転（auto_center 対応）。

        引数:
            auto_center: bool
            pivot: vec3, range [(-300.0, -300.0, -300.0), (300.0, 300.0, 300.0)]
            angles_rad: vec3, range [(-3.141592653589793, -3.141592653589793, -3.141592653589793), (3.141592653589793, 3.141592653589793, 3.141592653589793)]
        """
        ...
    # meta: auto_center (type=bool)
    # meta: pivot (type=vec3, range=[(-300.0, -300.0, -300.0), (300.0, 300.0, 300.0)])
    # meta: scale (type=vec3, range=[(0.1, 0.1, 0.1), (5.0, 5.0, 5.0)])
    def scale(self, *, auto_center: bool = ..., pivot: Vec3 = ..., scale: Vec3 = ..., **_params: Any) -> _PipelineBuilder:
        """
        スケール変換を適用（auto_center 対応）。

        引数:
            auto_center: bool
            pivot: vec3, range [(-300.0, -300.0, -300.0), (300.0, 300.0, 300.0)]
            scale: vec3, range [(0.1, 0.1, 0.1), (5.0, 5.0, 5.0)]
        """
        ...
    # meta: subdivisions (type=integer, range=[0, 10])
    def subdivide(self, *, subdivisions: int = ..., **_params: Any) -> _PipelineBuilder:
        """
        中間点を追加して線を細分化。

        引数:
            subdivisions: integer, range [0, 10]
        """
        ...
    # meta: delta (type=vec3, range=[(-500.0, -500.0, -500.0), (500.0, 500.0, 500.0)])
    def translate(self, *, delta: Vec3 = ..., **_params: Any) -> _PipelineBuilder:
        """
        指定ベクトルで平行移動。

        引数:
            delta: vec3, range [(-500.0, -500.0, -500.0), (500.0, 500.0, 500.0)]
        """
        ...
    # meta: start_param (type=number, range=[0.0, 1.0])
    # meta: end_param (type=number, range=[0.0, 1.0])
    def trim(self, *, start_param: float = ..., end_param: float = ..., **_params: Any) -> _PipelineBuilder:
        """
        ポリラインの一部区間だけを残す。

        引数:
            start_param: number, range [0.0, 1.0]
            end_param: number, range [0.0, 1.0]
        """
        ...
    # meta: angle_rad (type=number, range=[0.0, 6.283185307179586])
    # choices: axis in ['x', 'y', 'z']
    def twist(self, *, angle_rad: float = ..., axis: str = ..., **_params: Any) -> _PipelineBuilder:
        """
        位置に応じて軸回りにねじる。

        引数:
            angle_rad: number, range [0.0, 6.283185307179586]
            axis: choices { 'x', 'y', 'z' }
        """
        ...
    # meta: num_candidate_lines (type=integer, range=[0, 500])
    # meta: relaxation_iterations (type=integer, range=[0, 50])
    # meta: step (type=number, range=[0.0, 0.5])
    def weave(self, *, num_candidate_lines: int = ..., relaxation_iterations: int = ..., step: float = ..., **_params: Any) -> _PipelineBuilder:
        """
        形状にウェブ状のストリング構造を追加。

        引数:
            num_candidate_lines: integer, range [0, 500]
            relaxation_iterations: integer, range [0, 50]
            step: number, range [0.0, 0.5]
        """
        ...
    # meta: amplitude (type=number, range=[0.0, 20.0])
    # meta: frequency (type=number, range=[(0.0, 0.0, 0.0), (0.2, 0.2, 0.2)])
    # meta: phase (type=number, range=[0.0, 6.283185307179586])
    def wobble(self, *, amplitude: float = ..., frequency: float | tuple[float, float, float] = ..., phase: float = ..., **_params: Any) -> _PipelineBuilder:
        """
        線にウォブル/波の歪みを追加（純関数）。

        引数:
            amplitude: 変位量（座標単位, mm 相当）
            frequency: 空間周波数 [cycles per unit]
            phase: 位相（ラジアン）
        """
        ...
    def build(self) -> Pipeline: ...
    def cache(self, *, maxsize: int | None) -> _PipelineBuilder: ...
    def label(self, uid: str) -> _PipelineBuilder: ...
    def cache_info(self) -> dict[str, int]: ...
    def clear_cache(self) -> None: ...
    def __call__(self, g: Geometry) -> Geometry: ...

class _Effects(Protocol):
    @property
    def pipeline(self) -> _PipelineBuilder: ...
    def label(self, uid: str) -> _PipelineBuilder: ...
    def affine(self, *, auto_center: bool = ..., pivot: Vec3 = ..., angles_rad: Vec3 = ..., scale: Vec3 = ..., delta: Vec3 = ..., **_params: Any) -> _PipelineBuilder: ...
    def boldify(self, *, boldness: float = ..., **_params: Any) -> _PipelineBuilder: ...
    def clip(self, *, outline: engine.core.geometry.Geometry | Sequence[engine.core.geometry.Geometry], draw_outline: bool = ..., draw_inside: bool = ..., **_params: Any) -> _PipelineBuilder: ...
    def collapse(self, *, intensity: float = ..., subdivisions: int = ..., **_params: Any) -> _PipelineBuilder: ...
    def dash(self, *, dash_length: float | list[float] | tuple[float, ...] = ..., gap_length: float | list[float] | tuple[float, ...] = ..., offset: float | list[float] | tuple[float, ...] = ..., **_params: Any) -> _PipelineBuilder: ...
    def displace(self, *, amplitude_mm: float | tuple[float, float, float] = ..., spatial_freq: float | tuple[float, float, float] = ..., t_sec: float = ..., **_params: Any) -> _PipelineBuilder: ...
    def drop(self, *, interval: int | None = ..., offset: int = ..., min_length: float | None = ..., max_length: float | None = ..., probability: float = ..., by: str = ..., seed: int | None = ..., keep_mode: str = ..., **_params: Any) -> _PipelineBuilder: ...
    def explode(self, *, factor: float = ..., **_params: Any) -> _PipelineBuilder: ...
    def extrude(self, *, direction: Vec3 = ..., distance: float = ..., scale: float = ..., subdivisions: int = ..., center_mode: str = ..., **_params: Any) -> _PipelineBuilder: ...
    def fill(self, *, angle_sets: int | list[int] | tuple[int, ...] = ..., angle_rad: float | list[float] | tuple[float, ...] = ..., density: float | list[float] | tuple[float, ...] = ..., spacing_gradient: float | list[float] | tuple[float, ...] = ..., remove_boundary: bool = ..., **_params: Any) -> _PipelineBuilder: ...
    def mirror(self, *, n_mirror: int = ..., cx: float = ..., cy: float = ..., source_side: bool | Sequence[bool] = ..., show_planes: bool = ..., **_params: Any) -> _PipelineBuilder: ...
    def mirror3d(self, *, n_azimuth: int = ..., cx: float = ..., cy: float = ..., cz: float = ..., axis: Sequence[float] = ..., phi0_deg: float = ..., mirror_equator: bool = ..., source_side: bool | Sequence[bool] = ..., mode: str = ..., group: str | None = ..., use_reflection: bool = ..., show_planes: bool = ..., **_params: Any) -> _PipelineBuilder: ...
    def offset(self, *, join: str = ..., segments_per_circle: int = ..., distance: float = ..., keep_original: bool = ..., **_params: Any) -> _PipelineBuilder: ...
    def partition(self, *, site_count: int = ..., seed: int = ..., **_params: Any) -> _PipelineBuilder: ...
    def repeat(self, *, count: int = ..., cumulative_scale: bool = ..., cumulative_offset: bool = ..., cumulative_rotate: bool = ..., offset: Vec3 = ..., angles_rad_step: Vec3 = ..., scale: Vec3 = ..., curve: float = ..., auto_center: bool = ..., pivot: Vec3 = ..., **_params: Any) -> _PipelineBuilder: ...
    def rotate(self, *, auto_center: bool = ..., pivot: Vec3 = ..., angles_rad: Vec3 = ..., **_params: Any) -> _PipelineBuilder: ...
    def scale(self, *, auto_center: bool = ..., pivot: Vec3 = ..., scale: Vec3 = ..., **_params: Any) -> _PipelineBuilder: ...
    def subdivide(self, *, subdivisions: int = ..., **_params: Any) -> _PipelineBuilder: ...
    def translate(self, *, delta: Vec3 = ..., **_params: Any) -> _PipelineBuilder: ...
    def trim(self, *, start_param: float = ..., end_param: float = ..., **_params: Any) -> _PipelineBuilder: ...
    def twist(self, *, angle_rad: float = ..., axis: str = ..., **_params: Any) -> _PipelineBuilder: ...
    def weave(self, *, num_candidate_lines: int = ..., relaxation_iterations: int = ..., step: float = ..., **_params: Any) -> _PipelineBuilder: ...
    def wobble(self, *, amplitude: float = ..., frequency: float | tuple[float, float, float] = ..., phase: float = ..., **_params: Any) -> _PipelineBuilder: ...

from .shapes import ShapesAPI as ShapesAPI

G: _GShapes
E: _Effects
cc: Any
from .lfo import lfo as lfo
from shapes.registry import shape as shape
from effects.registry import effect as effect
from .layers import L
from engine.render.types import Layer
from .sketch import run_sketch as run_sketch, run_sketch as run
__all__ = [
    'G', 'E', 'cc', 'lfo', 'shape', 'effect', 'run_sketch', 'run', 'ShapesAPI', 'Geometry', 'L', 'Layer',
]
