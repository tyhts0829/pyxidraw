# offset 高速化チェックリスト（提案）

- どこで: `offset` 実装（ファイル/関数名は未確認）
- 何を: ポリライン/ポリゴンのオフセット計算を高速化
- なぜ: 大規模パスでの待ち時間短縮、描画全体のスループット向上

---

## スコープ / 対象

- 対象: 2D ポリライン/ポリゴンのオフセット（miter/bevel/round ジョイン、cap は butt/square/round を想定）
- 入出力: `float64`（許容で `float32` 切替）、C-contiguous `(N, 2)`
- 可変長複数パスは「パス単位」で並列/バッチ処理

## 完了条件（この変更単位）

- 変更ファイルに対し `ruff/mypy/pytest` 緑（編集ファイル限定の高速ループで確認）
- 代表入力（小/中/大 N）で 2x 以上の実行時間短縮（初回 JIT コンパイルを除く）
- 幾何学的に破綻しない（NaN/Inf/ゼロ長の発生なし、閉路/開路の扱いが仕様通り）
- Numba が無い環境でもフォールバックで正しく動作

## 要回答（確認事項）

- 現行 `offset` 実装の所在: ファイルパス/関数名（例: `src/engine/core/geometry.py:offset_path`）
- 入力の仕様: 開路/閉路の混在可？ clockwise/counter-clockwise の維持要件？
- ジョイン/キャップ: 許可される種類と既定値（miter/bevel/round、butt/square/round）
- miter limit の既定値（例: 4.0）と丸め角分割の上限/下限
- 許容誤差（例: `1e-6`）と出力スナップの有無
- Numba 依存追加の可否（optional/extra 扱いで良いか）

## 要承認（Ask-first）

- 依存追加: `numba`（optional: `pip install numba`、セットアップへの追記）
- ベンチマーク用 `tests/perf` 追加（任意。CI 負荷に注意）

---

## 実施チェックリスト（反復可）

### 1) 基線計測・現状把握

- [ ] 代表データ作成（小: N≈100, 中: N≈5k, 大: N≈50k）
- [ ] マイクロベンチ（`time.perf_counter()`）で現行 `offset` を測定
- [ ] cProfile/line_profiler（任意）でホットスポット特定
- [ ] 退化ケース（ゼロ長、重複点、鋭角）での挙動確認

### 2) データ整形・前処理

- [ ] `np.ascontiguousarray` と `dtype` 統一（既定 `float64`）
- [ ] ゼロ長セグメント除去/結合（`eps` しきい値導入）
- [ ] 開路/閉路の正規化（閉路なら終点=始点の重複を避ける）

### 3) ベクトル化と事前メモリ確保

- [ ] セグメント差分 `v = p[1:] - p[:-1]`、長さ `L`、法線 `n` を一括計算
- [ ] 頂点法線の合成（前後セグメント法線の正規化→合成→再正規化）
- [ ] 出力サイズの見積もり（bevel/round に備え 2 パス構成：カウント→書き込み）
- [ ] ループ中の `np.concatenate/stack` 排除、バッファ直接書き込み

### 4) ジョイン/キャップ最適化

- [ ] miter limit 導入（閾値超過で bevel/round にフォールバック）
- [ ] 丸め角の分割数を角度に比例して算出（最小/最大分割でクリップ）
- [ ] ほぼ直線の角は近似（合成法線をそのまま適用）
- [ ] cap（開路端）の処理を分岐最小化

### 5) Numba（njit）適用

- [ ] コア関数分割：
  - [ ] `compute_segments(points) -> (v, L, n)`
  - [ ] `compute_vertex_normals(n_prev, n_next) -> nv`
  - [ ] `apply_offset(points, nv, d) -> points_out`
- [ ] `@njit(nopython=True, fastmath=True, cache=True)` でまず単一スレッド化
- [ ] 可変長出力部（round/bevel 生成）は Python 側に残しつつ、計算カーネルのみ JIT
- [ ] 複数パス処理がある場合は `prange(num_paths)` で「パス単位」に並列化
- [ ] Numba 非導入時のフォールバック経路を保持（機能同等）

### 6) 並列化/バッチ処理

- [ ] 複数パスをまとめて処理（可変長はオフセット配列＋インデックスで表現）
- [ ] 1 パスのみの場合はシングルスレッド維持（同期・割り当てオーバーヘッドを回避）

### 7) 精度/安定性

- [ ] `eps` を統一（直交化・正規化時のゼロ割回避）
- [ ] 必要に応じ `float32` モードを追加（誤差と速度のトレードオフを明記）
- [ ] `fastmath` の影響が出やすい角での差分確認（鋭角/鈍角）

### 8) テスト/ベンチ/CI

- [ ] 形状別の単体テストを追加（直線/矩形/星形/ランダム折れ線、開路/閉路）
- [ ] 幾何的健全性の簡易検査（NaN なし、自己交差の極端な悪化なし、点数上下限）
- [ ] ベンチスクリプト（ローカル実行のみ）で効果測定と結果記録
- [ ] 変更ファイルに限定して `ruff/mypy/pytest -q -k offset` を高速ループで実行

### 9) ドキュメント/公開 API

- [ ] 関数 docstring（NumPy スタイル、日本語の事実記述）
- [ ] パラメータ（距離/ジョイン/キャップ/miter limit/丸め角密度）は実値受け取り（変換レイヤ撤廃）
- [ ] `architecture.md` 差分があれば更新（参照コード行を併記）

---

## ベンチ指標（例）

- 小（N≈100）: 5ms → 1–2ms
- 中（N≈5k）: 30ms → 10–15ms
- 大（N≈50k）: 300ms → 120ms 以下
- メモリ: 一時配列は O(N)、2 パス方式でピーク抑制

## リスクと対策

- JIT 初回コスト: `cache=True`、起動時ウォームアップを任意導入
- 数値誤差: miter/round の閾値調整、`fastmath` の限定適用
- 可変長生成の複雑化: 2 パス（カウント→書込）で単純化
- 依存追加: `numba` は optional 扱い、無い環境はフォールバック

## 追加提案（任意・将来）

- `guvectorize(target="parallel")` によるパス単位 ufunc 化（固定長またはパディング前提）
- Douglas–Peucker による事前簡略化（誤差許容を小さめに）
- 並列 I/O と計算の重ね合わせ（ワーカーがある場合）

---

## 次アクション（要ご確認）

- [ ] 現行 `offset` のファイル/関数名・仕様をご提示ください
- [ ] Numba を optional 依存として追加して良いかご判断ください
- [ ] 目標ベンチ指標の妥当性（上記値）を調整してください

> ご確認後、このチェックリストに沿って段階的に実装します。進捗は本ファイルのチェックを更新して共有します。

