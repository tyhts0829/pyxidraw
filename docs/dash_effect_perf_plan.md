# dash エフェクト: パフォーマンス改善計画

## ゴール
- 現状の dash エフェクトのアルゴリズム（2 パス + Numba）を維持しつつ、典型的なユースケースでの処理時間を短縮する。
- 単一パターン（スカラー指定）と短い list パターンで特に高速に動作させる。
- 実装はシンプルさと可読性を保ち、既存テストの挙動を変えない。

## 現状整理
- 実装構造:
  - Python 層: `dash()` が `coords/offsets` を 2 パス（count → fill）で処理。
  - Numba 層: `_count_line` / `_fill_line` が 1 行ごとの弧長配列 `s` を計算し、ダッシュ区間をサイクルパターンで生成。
  - 各行につき 2 回 `astype(np.float32, copy=False)` + Numba 呼び出しが発生。
- 想定ボトルネック:
  - 長いライン数・頂点数が多い場合の弧長計算と `np.searchsorted` の繰り返し。
  - Python 側での per-line ループ + 2 回の JIT 呼び出し（count/fill）。
  - list パターン時のサイクル処理での modulo インデックス計算。

## 改善方針（高レベル）
- [ ] まずプロファイルを取り、実測でどこが支配的かを把握する（推測だけで手を入れない）。
- [ ] 2 パス構造（count → allocate → fill）は維持しつつ、不要な再計算・変換を削減する。
- [ ] 「スカラー dash/gap の単一パターン」と「短い list パターン」に最適化した fast path を用意し、それ以外は現状ロジックを使う。
- [ ] Numba JIT 前提のコードを極端に複雑化しない（Numba 無効時でもそこそこの性能を保つ）。

## ステップ 1: プロファイルとベースライン
- [ ] 代表的なケースを決めてベンチマークシナリオを作る。
  - [ ] 長い単一ライン（例: N=1e5, dash/gap 単一スカラー）。
  - [ ] 多数の短いライン（例: N_lines=1e3, 各 20 点程度のポリライン）。
  - [ ] list パターン（`dash_length=[1,3,2], gap_length=[2,2,2]` など）の実運用に近いケース。
- [ ] 既存のベンチ/プロファイル仕組み（`tools/bench` もしくは ad-hoc スクリプト）で `dash` 単体の処理時間を測定し、現状値を記録する。
- [ ] Numba 有効/無効の両方のパフォーマンスを確認し、最適化対象を決める（Numba 依存度のバランスを判断）。

## ステップ 2: Python 層のオーバーヘッド削減
- [ ] `dash()` 内の per-line ループでの `astype(np.float32, copy=False)` を見直す。
  - [ ] 入力 `coords` がすでに `float32` の場合は、事前に 1 回だけ変換して全行共通で使うようにする。
- [ ] `_count_line` / `_fill_line` 呼び出しに渡す配列を可能な限り再利用し、不要な一時配列生成を減らす（Numba 側の仮想マシンに任せられる部分は任せる）。
- [ ] list パターン用の `dash_arr` / `gap_arr` / `offset_arr` の作成を 1 回にまとめ、行ごとに新しい view を作らないように確認する（現状維持かを確認）。

## ステップ 3: Numba kernels のマイクロ最適化
- [ ] `_count_line` / `_fill_line` の弧長計算部分を共通化する余地を検討する。
  - [ ] 1 行ごとの弧長 `s` を 2 回計算しているが、`_count_line` と `_fill_line` を 1 つの kernel に統合するか、あるいは「count パスでは `s` を計算せず近似で見積もる」などの案を比較する。
  - [ ] コード複雑度と性能改善のトレードオフを評価し、メリットが小さければ現状の 2 回計算を維持する。
- [ ] サイクルパターンのループ内での `if di >= n_dash: di = 0` / `if gi >= n_gap: gi = 0` を、`%` 演算とどちらが速いか試し、分岐を含めた最適形を決める（Numba の最適化特性を実測で判断）。
- [ ] `np.searchsorted` の呼び出し回数が支配的になっている場合、簡易な線形探索や前回 index を初期値にしたローカル探索などの代替が有効かをプロトタイプで検証する。

## ステップ 4: fast path の導入
- [ ] 「単一パターン（スカラー）」専用の fast path を用意する。
  - [ ] `dash_lengths.size == 1` かつ `gap_lengths.size == 1` の場合、より単純な kernel（もしくは既存 kernel の分岐）を用いてループを最適化する。
  - [ ] 具体例: u 軸の `u_pos` 更新や `di/gi` のサイクル処理を外し、パターンが一定である前提のループに簡略化する。
- [ ] 「短い list パターン（サイズ 2〜4）」にも fast path を適用するか検討する。
  - [ ] コード膨張と可読性低下のコストを見つつ、効果が小さければ単一パターン fast path のみに限定する。

## ステップ 5: 退行防止と安全性
- [ ] すべての dash テスト（既存 + 追加）を実行し、挙動の変化が無いことを確認する。
- [ ] バグ対策で追加した「実線ゼロケース」関連のテスト（全 0 ダッシュ長、offset を含むケース）が引き続き緑かを確認する。
- [ ] 極端な入力（非常に長いライン、多数のライン、小さな/大きなパラメータ）に対する簡易ストレステストを行い、数値的不安定性やオーバーフローが無いことを確認する。

## ドキュメント/コメント
- [ ] `src/effects/dash.py` 冒頭の実装メモに「パフォーマンス上の設計意図」（2 パスにしている理由、Numba 前提など）を 1〜2 行で追記する。
- [ ] fast path を導入する場合は、その分岐条件と意図を短くコメントに残す（将来の保守者向けに「なぜこの分岐があるか」を明示）。
- [ ] 性能特性が変わるほどの改善が入った場合は、必要に応じて `benchmark_results` の更新や簡単な perf レポートを残す。

