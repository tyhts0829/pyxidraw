# repeat エフェクト 仕様案 / アイデアメモ

本書は、入力ジオメトリを複製して規則的な配列を作るエフェクト `repeat` の  
「柔軟かつ直感的」な仕様イメージを整理するためのメモである。

目的は、少ないパラメータで以下のようなパターンを素直に作れること:

- 平行移動による等間隔の列・グリッド
- 回転による放射状の配列
- スケール変化による同心円 / 多層構造（等間隔の縮小・拡大を含む）

既存の `repeat` 実装（`cumulative` 引数あり）をベースに、  
「モードの意味」と「scale の扱い」を明確にする方向で提案する。

---

## ゴール / コンセプト

- 単純なメンタルモデル:
  - 「コピー番号 `n` に応じて、スケール・回転・平行移動を決める」だけにする。
- 2 つのモードで大半の用途をカバー:
  - 累積モード: 前のコピーにさらに変換を重ねる（螺旋・反復変形向き）。
  - 非累積モード: 元ジオメトリからの相対変換（等間隔配置・同心円向き）。
- `scale` は「モードごとに一貫したルール」で扱う:
  - 累積モード: 乗算（幾何級数）で増減。
  - 非累積モード: 線形補間で増減（等間隔の同心円を作りやすくする）。

---

## ユースケース例

- 平行移動:
  - ストロークを X 方向に 10mm ずつずらして 5 本並べる。
- 回転:
  - 花びら状に、中心から放射状にコピーを並べる（回転のみ、スケール 1）。
- 同心円:
  - 半径 1.0 の円から、0.8, 0.6, 0.4 のように「等間隔」で縮小した円を重ねる。
- 反復変形:
  - 毎回 0.9 倍スケール + 少し回転して、内側に巻き込むような螺旋パターンを作る。

---

## 公開 API イメージ

`api.E.pipeline` からの利用イメージ:

```python
from api import E

pipe = (
    E.pipeline
    .repeat(
        count=4,                    # コピー数
        cumulative=False,           # 非累積モード（同心円など）
        offset=(0.0, 0.0, 0.0),     # 平行移動ステップ
        angles_rad_step=(0.0, 0.0, 0.0),  # 回転ステップ [rad]
        scale=(0.4, 0.4, 1.0),      # 非累積モードでは「最終コピーのスケール」
        auto_center=True,           # 中心は自動で形状の平均座標
        pivot=(0.0, 0.0, 0.0),      # auto_center=False 時の中心
    )
    .build()
)

g2 = pipe(g1)
```

同心円イメージ（半径 1.0 の円から 0.8 / 0.6 / 0.4 にしたい場合）:

- `count=3`
- `cumulative=False`
- `scale=(0.4, 0.4, 1.0)` とすると:
  - 元: 1.0
  - コピー1: 0.8
  - コピー2: 0.6
  - コピー3: 0.4

（詳細は後述の「スケール挙動」参照）

---

## コア設計方針

### 1. インスタンス番号とコピーの定義

- 入力 Geometry を `g` とし、`count` を「コピー数」とする。
- `repeat` の出力は常に「元 + count 個のコピー」とする。
  - インスタンス番号 `i`:
    - `i = 0` : 元ジオメトリ（変換なし）。
    - `i = 1..count` : `i` 番目のコピー。
- 実際の変換は「インスタンス番号 `i`」と「モード」に基づいて決まる。

### 2. モード: 累積 / 非累積

`cumulative: bool` でモードを切り替える。

#### 累積モード (`cumulative=True`)

- メンタルモデル:
  - 「前のコピーに、毎回同じ変換をさらに掛けていく」モード。
- 実装イメージ:
  - `base = g`（元）
  - for `i in 1..count`:
    - `current = transform_step(current)` を繰り返す。
    - `transform_step` は `scale`・`angles_rad_step`・`offset` に基づく 1 ステップ分の変換。
- 特徴:
  - スケールは毎回乗算されるため、`scale=(0.8,0.8,1.0)` なら `1.0, 0.8, 0.64, 0.512,...` のように幾何級数的に縮む。
  - 回転や平行移動もコピーが進むほど累積していく（螺旋や複雑な軌跡向き）。

#### 非累積モード (`cumulative=False`)

- メンタルモデル:
  - 「毎回、元のジオメトリに対して `i` に応じた変換を一発で掛ける」モード。
- 実装イメージ:
  - `base = g`（元）
  - for `i in 1..count`:
    - `transform(base, i)` で「コピー番号 i に対応する変換」を計算する。
- 特徴:
  - 平行移動/回転: インスタンス番号に比例した量を元ジオメトリに適用（後述）。
  - スケール: 「1 から scale までを線形補間」する（後述）。
  - 等間隔のグリッド / 同心円など、「コピー番号に応じて素直に増減してほしい」用途を想定。

---

## 変換ごとの挙動

### 1. 平行移動 `offset`

`offset: Vec3` は「1 ステップあたりの並進量」として扱う。

- 累積モード:
  - 各コピーは「前のコピーから `offset` だけ移動したもの」として実装する。
  - インスタンス番号に対する位置は結果として幾何学的に累積する。
- 非累積モード:
  - インスタンス番号 `i` に対して `offset_i = offset * i` を元ジオメトリに直接適用。
  - 例: `offset=(10,0,0), count=3` → X=0,10,20,30 の 4 本（元 + 3 コピー）が得られる。

### 2. 回転 `angles_rad_step`

`angles_rad_step: Vec3` は「1 ステップあたりの回転量 [rad]」として扱う。

- 累積モード:
  - 各コピーで「前のコピーから `angles_rad_step` だけ回転」させる。
  - 実装上は「インスタンス番号に応じた合成角」を用いてもよいが、メンタルモデルは「毎回同じだけ回す」。
- 非累積モード:
  - インスタンス番号 `i` に対して `angles_i = angles_rad_step * i` を元ジオメトリに適用。
  - 例: `angles_rad_step=(0,0,π/4), count=3` → 0°,45°,90°,135° の 4 本。

中心の扱いは既存どおり:

- `auto_center=True` → ジオメトリの平均座標を中心に使用。
- `auto_center=False` → `pivot` を中心に使用。

### 3. スケール `scale`

`scale: Vec3` の扱いは、モードごとに明確に変える。

#### 累積モード (`cumulative=True`)

- スケールは「乗算」による幾何級数とする。
- メンタルモデル:
  - 「毎回 `scale` 倍する」。
- 具体:
  - スケールベクトル `S_i` を:
    - `S_0 = (1,1,1)`（元）
    - `S_i = S_{i-1} * scale`（要素ごとの乗算）
  - 例: `scale=(0.8,0.8,1.0), count=3`:
    - 元: 1.0
    - コピー1: 0.8
    - コピー2: 0.64
    - コピー3: 0.512

#### 非累積モード (`cumulative=False`)

- スケールは「1 から `scale` まで線形補間」する。
- メンタルモデル:
  - 「コピー番号に応じて、一定刻みで大きさが変わる」。
  - 同心円などで「半径を等間隔にしたい」ケースを優先。
- 具体:
  - インスタンス番号 `i`（1..count）、補間係数 `t = i / count` とする。
  - スケールベクトル `S_i` は:
    - `S_0 = (1,1,1)`（元）
    - `S_i = (1 - t) * (1,1,1) + t * scale`
  - 例: `scale=(0.4,0.4,1.0), count=3`:
    - `i=0` : 1.0
    - `i=1` : 0.8
    - `i=2` : 0.6
    - `i=3` : 0.4

この挙動により、

- 累積モード: 「だんだん加速して変化する」反復変形。
- 非累積モード: 「終点を決めて、その間を均等に割る」配列。

という役割分担が明確になる。

---

## GUI / `__param_meta__` のイメージ

`repeat.__param_meta__` のパラメータ自体は現状とほぼ同じでよいが、  
`cumulative` の説明を「スケールを含めたモード切り替え」として明示する。

```python
PARAM_META = {
    "auto_center": {"type": "bool"},
    "cumulative": {"type": "bool"},
    "count": {"type": "integer", "min": 0, "max": 100, "step": 1},
    "offset": {
        "type": "vec3",
        "min": (-300.0, -300.0, -300.0),
        "max": (300.0, 300.0, 300.0),
    },
    "angles_rad_step": {
        "type": "vec3",
        "min": (-math.pi, -math.pi, -math.pi),
        "max": (math.pi, math.pi, math.pi),
    },
    "scale": {"type": "vec3", "min": (0.5, 0.5, 0.5), "max": (1.5, 1.5, 1.5)},
    "pivot": {
        "type": "vec3",
        "min": (-300.0, -300.0, -300.0),
        "max": (300.0, 300.0, 300.0),
    },
}
```

GUI 上の説明文イメージ:

- `cumulative=True`:
  - 「前のコピーにさらに変換を重ねる（scale は乗算）」。
- `cumulative=False`:
  - 「元ジオメトリからの相対変換（scale は 1→scale を線形補間）」。

---

## 今後の検討ポイント / 質問候補

- 非累積モードで「スケールをまったく変えない」専用の簡易モードが欲しいか:
  - 例: `scale=None` を許すか、`scale=(1,1,1)` を事実上の no-op とするか。
- 「コピー番号 `n` を参照するエクスポート API」（ランダムや LFO と組み合わせるため）を  
  将来的に追加したくなるかどうか。
- 既存スケッチとの互換性:
  - 現行 `repeat` の挙動（特に `cumulative=False` 時のスケール）からどこまで変えてよいか。
  - 破壊的変更を許容する場合でも、移行のためのメモを `repeat_effect_plan.md` に追記するか。

