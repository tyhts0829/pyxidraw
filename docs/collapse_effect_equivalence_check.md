# collapse 現実装の挙動精査と v2 最適化案の等価性チェック

対象: `src/effects/collapse.py`

目的: 既存挙動（非接続・各サブセグメント=2頂点の独立ポリライン）を維持したまま、
docs/collapse_effect_optimization_v2.md の方針で効率化しても“見た目の効果が変わらない”かを精査する。

---

現実装の要点（挙動の事実）
- 細分化: 各元セグメントを `D=subdivisions` 分割し、D 本のサブセグメントを生成。
- 非接続出力: 各サブセグメントは長さ2の独立ポリラインとして出力（オフセットは 2 ずつ伸びる）。
- ノイズ方向: 主方向 `n=normalize(B-A)` と乱数ベクトル `r ~ N(0, I)` の外積 `cross(n, r)` を正規化。
  - 外積の正規化により、平面（n に直交）内で“方向は一様”になる。
  - 退避: `||cross(n,r)|| < eps` の稀ケースではノイズを載せず原セグメントをそのまま出力。
- 振幅: `intensity` をそのままスカラーとして使用（全サブセグメントで一定）。
- seed: 関数先頭で `np.random.seed(0)`（実質固定）。以後 `np.random.randn` を逐次呼び出し。
- dtype: 出力は float32、offsets は int32。

---

v2 最適化案（互換維持版）の骨子（再掲）
- 2 パス（count/fill）＋前方確保。
- サブセグメント端点 `starts=(1-t0)A+t0B`, `ends=(1-t1)A+t1B` をベクトル化で生成（D 個）。
- ノイズ方向は「平面内一様」を維持し、振幅は `intensity` 一定。
- 各サブセグメントごとに 2 頂点を書き、offsets を 2 ずつ進める（非接続）。

---

一致点（= 互換に必要十分な条件）
1) 非接続のまま: サブセグメントは 2 頂点の独立ポリラインで出力する。
2) 振幅一定: 各サブセグメントのノイズ振幅は常に `intensity`。
3) 方向分布: 平面内一様。実装は次のいずれでも等価（分布レベル）:
   - 現実装: `normalize(cross(n, randn(3)))`
   - 代替: `cosθ·u + sinθ·v`（θ ~ U[0,2π), u,v は n に直交の正規直交基底）
4) 退避動作: 方向が不安定（`||cross||<eps` 等）のときノイズなしで原セグメントを出力。
5) dtype/形状: 出力は float32、offsets は int32。1点ライン/0長セグメントの扱いも不変。
6) 細分の順序: t は 0→1 の昇順。出力サブセグメントの順序も元セグメントの並び・t 昇順に一致。

---

差異の可能性と対策
- 方向生成の方式
  - 角度一様（cos/sin）方式は“分布としては等価”だが、乱数系列が変わるため画素単位の見えは完全一致にならない可能性がある。
  - 対策（完全一致志向）: 現実装と同じく `randn(D,3)` を用いて `cross(n, ·)` をベクトル化し、その結果を正規化する。

- 乱数のシードと発生順
  - `np.random.seed(0)` 後に `randn` をループで 3 個ずつ消費する現在の順序と、ベクトル化で `randn(D,3)` を一括消費する順序は一致する（総消費数が同じで順番が同じ）ため、同じ系列になる。
  - 対策: 1セグメントごとに `randn(D,3)` を発生させ、処理順を「元セグメント昇順→サブセグメント昇順」に固定する。
  - 注: `Generator`（PCG64）に切り替えると系列が変わるため、完全一致が必要なら旧 `np.random` API を継続利用する。

- 直交基底の構築
  - 角度方式では `u,v` 基底を必ず構築するが、現実装は `cross(n, r)` 依存で稀に退避（ノイズなし）。
  - 対策: 角度方式を採る場合でも “角度生成に失敗” 相当の微小確率イベントを模倣する必要はない（見た目差は無視可能）。完全一致志向なら `cross(n, randn)` を採用する。

- EPS とゼロ長判定
  - `EPS=1e-12` を踏襲し、`||B-A||<=EPS` では 2 頂点をそのまま出力（ノイズ無し）。

---

結論（可否判断）
- 分布レベルの互換で良ければ、v2 案（角度一様方式）で見た目は変わらない。非接続・振幅一定・方向一様の要件を満たす。
- 完全一致（同一入力で同一点群）を求める場合は、以下を満たせば現実装と一致する:
  1) 関数冒頭で `np.random.seed(0)` を維持（グローバル RNG）。
  2) 各元セグメントごとに `randn(D,3)` を発生（処理順はセグメント昇順→サブセグメント昇順）。
  3) 方向は `normalize(cross(n, randn))` を使用。`||·||<eps` のときはノイズ無しで出力。
  4) 出力は float32、offsets は各サブセグメントで 2 ずつ増分（1点ラインは +1）。

---

適用チェックリスト（実装者向け）
- [ ] 非接続出力（各サブセグメントは 2 頂点の独立ポリライン）を維持
- [ ] 2 パス（count/fill）と前方確保でメモリ効率化
- [ ] t グリッドの共有（`t0=t[:-1]`, `t1=t[1:]`）
- [ ] 方向は `cross(n, randn)` のベクトル化（完全一致志向）もしくは角度一様（分布互換志向）
- [ ] `np.random.seed(0)` を維持し、乱数の消費順を保証（セグメント→サブセグメント）
- [ ] EPS=1e-12 で 0 長退避、直交の微小ノルム退避を反映
- [ ] dtype を float32/int32 に統一、offsets は 2 ずつ進める

