# 改善点

- アーキテクチャ：api/effects.py や effects/fill.py のように 1 ファイルに非常に多くの責務が詰まっているモジュールがあり、将来の拡張やバグ調査の観点では分割した方がよい。例えばパイプライン関連（ハッシュ、コンパイル、実行）をサブモジュールに分ける、fill を「ポリゴングルーピング」「スキャンライン」「角度セット」くらいに分割する、といった整理が考えられる。
- アーキテクチャ：shape 間でパラメータ名が微妙に揺れている（segments / n_sides など）箇所があり、ユーザ API としては用語を統一した方が混乱が少ない。既存コードへの影響を抑えるなら、内部名は統一しつつ alias を残す形が現実的。
- アーキテクチャ：パイプライン側で Geometry のハッシュを毎回配列から計算している構造になっており、本質的には「ジオメトリの内容ハッシュ」は Geometry クラス側で責務を持たせてキャッシュしておく方が筋が良い。これを Geometry 側に寄せると、パイプラインのコードも簡潔になり、ハッシュ計算の重複も避けられる。
- アーキテクチャ：一部の effect（collapse, displace など）で乱数シードやノイズの決定性が固定値に埋め込まれており、挙動を変えたい場合に API レベルで制御できない。seed や「フレーム依存かどうか」といったパラメータを追加して、インタラクティブ用途・静止画用途それぞれに最適化できる余地がある。
- 可読性：mirror / mirror3d や fill のような幾何アルゴリズム実装は、分岐とインデックス操作が多く、現状でもコメントは丁寧だが、それでも追うのにややコストがかかる。テストコードやドキュメントに「図解」「ケースごとの振る舞い例」を追加する、あるいはクリッピングや交点計算部分をもっと小さな関数に分割することで、将来の自分が読み返す負荷を下げられる。
- 可読性：text.text() や api/effects.py 内の一部メソッドは 1 関数の中で「レイアウト」「パラメトリック検証」「実処理」「キャッシュキー生成」までまとめて処理しているので、ロジックごとに関数を分けた方が見通しがよくなる。特に layout・描画・キャッシュを分離できると、挙動変更時の影響範囲も把握しやすい。
- 可読性：長いモジュールは、ファイルの先頭に「このファイル内のセクション一覧（簡易 TOC）」コメントを置いておくか、セクションごとに明確な区切りコメントを入れておくと、エディタでのナビゲーションがしやすくなる。既にある程度やっている箇所もあるが、api/effects などは特に効果が大きい。
- パフォーマンス：trim のようなポリライン処理で距離配列を Python ループで構築している箇所は、np.diff ＋ np.linalg.norm ＋ np.cumsum で簡単にベクトル化できるので、長い線分を大量に扱うケースでは速度向上が見込める。
- パフォーマンス：mirror / mirror3d のクリッピング処理は、頂点ごとに Python ループで分岐しているため、頂点数が非常に多い入力に対してはボトルネックになりうる。ここを numba で JIT する、あるいは一部ロジックだけでもベクトル化することで、極端なケースの耐性が上がる。
- パフォーマンス：effects/mirror の重複線分除去は、座標を量子化して巨大なタプルをキーに set で判定しているため、点数が多い線分を大量に流すと Python オブジェクトの生成コストが支配的になりうる。tobytes() をハッシュキーにする、あるいは numba 側でハッシュしてインデックスだけ Python に戻すなど、より軽量なキー表現にできる余地がある。
- パフォーマンス：util/load_config が毎回 YAML ファイルを読みに行く形なら（利用頻度によるが）、モジュール内キャッシュを挟んで 1 度だけ読むようにした方がよい。設定を頻繁に変える運用でない限り、I/O を減らせる。フォント探索結果も同様に、プロセス内での再利用を前提にキャッシュ層を明示しておくと安心。
