# レンダリングAA導入・段階評価計画（提案）

目的: 画質と実行コストのトレードオフを各段階で検証し、合意したものから順に導入する。

---

## 評価方法（共通）
- スクリーンショット: `P`（通常）/ `Shift+P`（高解像・overlay無）で保存し、ビフォー/アフターを比較。
- 視覚指標: ジャギーの残存、端のにじみ過多、細線の消失、継ぎ目の破綻（45°/浅い/急激な角）
- 性能指標: FPSの平均/最小、フレーム時間のp50/p95（HUD表示が無ければ一時的に計測を追加）
- 検証シーン（固定）:
  - 水平/垂直/45°の長い線、厚み: 0.4px/1px/2px/4px 相当
  - 折れ線（鋭角/鈍角）、密集パラレル線（1px 間隔）
  - ズーム有無（等倍/2x）と濃淡の背景

記録テンプレ（各段階で追記）:
- 改善点: …
- 退行: …
- スクショ: 通常/高解像パスのファイル名
- FPS: avg/min, フレーム時間: p50/p95（任意）

---

## 性能推定の前提
- 解像度: 1920x1080 を基準（4Kではフルスクリーン処理系は概ね2〜4倍）
- GPU想定: 近年のノート向けdGPU/統合GPU相当（中程度）。CPUはボトルネックになりにくい想定。
- 描画内容: 画面の5〜15%程度が線で占有（極端な塗りつぶしは除外）。
- いずれも概算の目安。環境・シーンで上下します。

## 参照ポイント（実装時）
- MSAA有効化: `src/engine/core/render_window.py:37`
- ブレンド設定: `src/api/sketch.py:321`
- 線生成シェーダ（要変更候補）: `src/engine/render/shader.py:21`, `src/engine/render/shader.py:46`
- オフスクリーン描画（PNG）: `src/engine/export/image.py:112`

---

## 段階的チェックリスト（効果とコストを逐次評価）

### 0) ベースライン確認（現状維持: MSAA 4x, 単色フラグメント）
- [ ] 再現用シーンを用意し描画（HUD必要ならON）
- [ ] 通常/高解像のスクショを保存し、基準フォルダを作成
- [ ] FPSとフレーム時間を記録（最低30秒）

出力物: baseline スクショ2枚、メモ（FPS/所感）

予想性能影響（基準）: ±0%

---

### 1) 線幅をピクセル基準へ（ジオメトリ）
狙い: 解像度やアスペクトに依存しない実線幅。MSAAの効果を安定化。
- 実装タスク（コード化は承認後）
  - [ ] ビューポート（ピクセル）→NDCへのオフセット変換を導入（x/yでスケール差異に対応）
  - [ ] `line_thickness` を「px相当」で受け取り、矩形拡張に反映
  - [ ] 既存呼び出し側（`LineRenderer`）の設定値をpx基準に見直し
- 検証/計測
  - [ ] 0.4px/1px線での太さ一貫性とジャギーの変化
  - [ ] FPS変動（±1fps以内を目安）
- ロールバック: フラグ `aa.pixel_thickness` で無効化

予想性能影響（1080p）
- GPU: 幾何シェーダ内の算術少量増のみ → ±0〜1%
- CPU/メモリ: 変化ほぼなし

---

### 2) フラグメントAA（法線方向カバレッジ、fwidth+smoothstep）
狙い: 矩形エッジをソフトにし極細線のちらつきを減少。
- 実装タスク
  - [ ] GEOMETRYで中心線からの距離（符号付き）をvaryingで渡す（px正規化が望ましい）
  - [ ] FRAGMENTで `fwidth()` を用いて1px相当のボーダー幅を取得し `smoothstep` でα補間
  - [ ] 出力αにカバレッジを乗算（`color.a *= coverage`）
- 検証/計測
  - [ ] 0.4px/1px線の視覚改善、にじみ過多がないか
  - [ ] FPS変動（±2%以内）
- ロールバック: フラグ `aa.fragment_coverage` で無効化

予想性能影響（1080p）
- 典型（細線・中密度）: +1〜2%
- 太線/高フィル率のシーン: +3〜5%（最悪 +8%）

---

### 3) SAMPLE_ALPHA_TO_COVERAGE を有効化（MSAA連携）
狙い: アルファをサンプルカバレッジへ反映し、サブピクセル細線の段差を更に低減。
- 実装タスク
  - [ ] `ctx.enable(moderngl.SAMPLE_ALPHA_TO_COVERAGE)` を有効化
  - [ ] 必要ならブレンド状態を再確認（事前のα乗算と競合しないか）
- 検証/計測
  - [ ] 細線の滑らかさ、太線の暗部ムラ有無
  - [ ] FPS変動（実測ほぼ±0%想定）
- ロールバック: フラグ `aa.alpha_to_coverage` で無効化

予想性能影響（1080p）
- ドライバ/環境依存だが概ね ±0〜1%

---

### 4) 書き出し品質の強化（SSAA継続 or MSAA-FBO resolve）
狙い: PNGなど静止画での高品位エッジ。
- 選択肢
  - [ ] SSAA: 既存 `scale=2.0` を標準化（UIから倍率選択）。縮小で高品質化。
  - [ ] MSAA-FBO: マルチサンプルFBOで描画→通常FBOへresolve（blit）
- 検証/計測
  - [ ] 書き出し時間（×解像度倍率）、見た目の差
- ロールバック: いつでもscale=1.0に戻す/resolveパスを無効化

予想性能影響
- ランタイム描画: 影響なし（書き出し専用）
- SSAA（scale=2.0）: フラグメント数約4倍 → 描画時間 3.5〜4.5倍 目安
- MSAA-FBO+resolve: シングルサンプル比 +5〜12% + resolve 0.2〜1.0ms（1080p）

---

### 5) 画面後処理のFXAA（任意）
狙い: 残留ジャギーの最終掃除。コストは比較的低いが若干のボケ。
- 実装タスク
  - [ ] 1パスのフルスクリーンシェーダ追加（既存FBOからテクスチャ入力）
- 検証/計測
  - [ ] 細部のボケ許容度、全体の滑らかさ
- ロールバック: `aa.fxaa` フラグ

予想性能影響
- 1080p: +1〜3%
- 4K: +3〜6%

---

### 6) 継ぎ目/端の形状改善（round/bevel/miter、adjacency使用）
狙い: 折れ点の破綻を解消し、cap/joinを滑らかに。
- 実装タスク
  - [ ] `lines_adjacency` で前後方向を取得し、ジオメトリでjoin/cap形状を生成
  - [ ] 形状端にも段階2のカバレッジAAを適用
- 検証/計測
  - [ ] 鋭角/鈍角の見た目、オーバードロー増分によるFPS変化
- ロールバック: `aa.joins_caps` フラグ

予想性能影響（シーン依存）
- 典型（角が適度、線本数中程度）: +3〜8%
- ワースト（角が多い密集折れ線）: +15〜25%

---

## 実施順（提案）
1. 0) ベースライン記録
2. 1) ピクセル基準化 → 計測
3. 2) フラグメントAA → 計測
4. 3) α→カバレッジ → 計測
5. 4) 書き出し品質（SSAA整理 or MSAA-FBO）
6. 5) FXAA（必要時）
7. 6) join/cap（必要時）

---

## 合意待ち（選択事項）
- ピクセル基準の定義: 「論理px（ウィンドウ）で固定」か「DPI感知」か
- デフォルトスケール: ランタイム1.0、書き出し2.0（推奨）でよいか
- 機能トグルの場所: `config.yaml` 直下（`aa.*`）に集約でよいか

---

## DoD（各段階の完了条件）
- 変更ファイルに対する `ruff/black/isort/mypy` 緑（コード変更段階）
- スクショ2枚（通常/高解像）と簡易メモを保存
- FPS/体感の退行が受容範囲内（±2〜3% 目安）

---

この計画で進めてよければ「承認」のコメントをください。必要に応じて順序/粒度を調整します。
