# collapse エフェクト効率化案 v2（互換重視・非接続仕様維持）

対象: `src/effects/collapse.py`

目的: 既存の見た目・出力構造（非接続仕様/パラメータの意味）を維持したまま、高速化とメモリ効率を改善する。破壊的な挙動変更は行わない。

変更しないこと（互換ガード）
- 細分化後にオフセットを与えた各セグメントは互いに接続しない（非接続）。
- すなわち、元ポリライン内の各サブセグメントは「長さ2の独立ポリライン」として出力する。
- `subdivisions` は「各元セグメントを D 分割」に固定（長さ連動の可変分割は導入しない）。
- ノイズは各サブセグメントで独立（相関導入なし）。分布特性は現状に準拠（角度は平面内一様、振幅は強度スケール＋必要に応じてガウス化）。
- 公開 API と `__param_meta__` は不変。

---

## 現状の概要（前提）

- 各セグメントを `subdivisions=D` で細分化し、小区間ごとに主方向ベクトルと直交するランダム方向へ平行移動して「崩し」を作る。
- 基本操作は「細分点の生成」「主方向の直交基底の構築」「乱数ベクトル生成」「平行移動」「連結書き出し」。

---

## 提案: 互換を保つ効率化（NumPy 中心、任意で Numba）

1) 2 パス前方確保（count → fill）
- 方針: 出力配列のサイズを事前に確定し、一括確保。最終的な `Geometry(out_coords, out_offsets)` を直接構築。
- count（1 本のポリライン、頂点数 m）
  - セグメント数 `S = m - 1`。
  - 非ゼロ長セグメント1本あたり `D` 本の独立ポリライン（各2頂点）を生成。
  - ゼロ長セグメントは 1 本（2 頂点）を生成。
  - 単一点のポリラインは 1 本（1 頂点）を保持。
  - よって「出力ポリライン本数」は `(#非ゼロ長セグメント)×D + (#ゼロ長セグメント) + (#単一点ライン)`。
  - 「出力頂点総数」は上記本数×2（単一点ラインは+1）。

2) サブセグメント端点のベクトル化生成（独立2点）
- 共有グリッド: `t = linspace(0, 1, D+1)` を一度だけ生成・キャッシュ（`t0=t[:-1]`, `t1=t[1:]`）。
- 各元セグメント i のサブセグメント端点は `start_i = (1-t0)*A_i + t0*B_i`, `end_i = (1-t1)*A_i + t1*B_i` をベクトル化で求め、長さ `D` の「独立2点ペア」列を得る。
- これにより各サブセグメントを 1 本の独立ポリラインとして、2 頂点×D を一括生成できる。

3) 直交基底の安定構築（セグメント単位、共有）
- 主方向 `n = normalize(B_i - A_i)`。
- 参照軸 `ref = (0,0,1)` を基本とし、`abs(n.z) >= 0.9` のときだけ `ref = (1,0,0)` に切替。`u = normalize(cross(n, ref))`, `v = cross(n, u)` として直交基底を得る。
- u,v はセグメント単位で1回だけ計算し、同セグメント内の全サブセグメントで使い回す（互換を維持しつつ計算削減）。

4) 乱数の一括生成（分布互換）
- 分布は現行に揃え、`theta ~ U[0, 2π)` として「平面内ランダム方向」を生成。振幅は `σ` を `intensity` に合わせてスケール（現実装の標準偏差に準拠）。
- ノイズベクトル: `noise = (cosθ) * u + (sinθ) * v` にスカラー振幅を掛ける。
- 実装は `Generator.random(size=D)` で一括サンプリングし、`theta = 2π * u` で生成。ループは「セグメント単位」のみに限定。

5) 書き込みのストライド代入
- `starts (D,3)` と `ends (D,3)` を用意し、ノイズ `noise (D,3)` を加えた後、
  `out_coords[vc : vc+2*D : 2] = starts + noise`, `out_coords[vc+1 : vc+2*D : 2] = ends + noise` と 2 ストライドで代入。
- `out_offsets` は各サブセグメントごとに現在の頂点カーソルに応じて `vc += 2; out_offsets[oc] = vc; oc += 1` を繰り返し更新（独立ラインを形成）。

6) Numba（任意・存在時のみ）
- ループの縮退後は Python オーバーヘッドは小さいが、さらに `njit` 化した 2 パス（count/fill）を用意可能。
- 乱数は `xorshift32 → θ = 2π * U[0,1)` で Box-Muller 不要（分布は角度均等）。ベクトルではなく逐次生成で OK（ループはセグメント単位まで縮退済み）。
- 使用可否は `PXD_USE_NUMBA_COLLAPSE` で opt-in/out。未導入環境は自動フォールバック。

---

## 計算量とメモリ

- 計算量: O(Σ S_i · D)（各ポリライン i のセグメント数 S_i と細分数 D）。
  - 直交基底はセグメント1回のみ、乱数と合成は長さ D の配列演算。
- メモリ: 出力配列は前方確保 1 回。中間の小配列や `vstack` を排除。

---

## 実装注意（互換維持のための細目）

- 接続性: セグメント間の共有端点について「片側のみ計算し採用」する（重複させない）。
- 分布: 角度一様（cos/sin）で平面内ランダム方向を作るのは現行の「直交ノイズ」解釈と整合。必要ならスカラー振幅に `np.random.randn(D)` を使ってガウス振幅に近づける（平均0、分散1）。
- dtype: 内部は float64 で計算し、最終的に float32 へキャストして Geometry へ。
- 安定性: 0 長セグメントはそのまま通過。`EPS=1e-12` を閾値に使用。
- キャッシュ: `t_grid_cache[D] = linspace(0..1, D+1)` をモジュール内でキャッシュし、短寿命の生成を避ける。

---

## テスト/DoD（変更単位）

- 構造保持
  - 各「元セグメント×subdivisions」のサブセグメントが、それぞれ 2 頂点の独立ポリラインとして出力される。
  - ゼロ長の元セグメントは 2 頂点（同一点）の独立ポリラインを 1 本出力。
  - 単一点ポリラインは 1 頂点の独立ポリラインを 1 本出力。
- 視覚的一貫性
  - 固定 seed（環境変数 or 引数で注入可能な設計）で旧版と比較し、頂点のばらつき統計が一致（平均≈0、分散比≈1±ε）。
  - 極短/ゼロ長での退避動作が一致（原状維持、NaN/inf 無し）。
- 性能
  - 大きめ入力（総セグメント数 1e5、D=6）で 1.5–3.0× 時間短縮（目安）。
- メモリ
  - ピーク常時 ≤ 出力配列 + 1–2 本の作業配列（t グリッド、ノイズ）。

---

## 実施チェックリスト（改善アクション）

- [x] 2 パス（count/fill）と前方確保の導入（独立2点ラインのまま）
- [ ] `t_grid_cache` による細分グリッドの再利用
- [x] 直交基底（u,v）のセグメント単位構築と共有
- [x] 乱数の一括生成（`Generator.random` / `Generator.standard_normal`）
- [x] ストライド代入（2ストライドで 2×D 頂点を書き込み）
- [x] 0 長/極短セグメントの退避処理（EPS）
- [x] 単体テスト（構造保持・統計・境界値）
- [x] 任意: `PXD_USE_NUMBA_COLLAPSE` 経路の用意（存在時のみ）

---

## リスク/回避策

- 乱数場の「見た目の揺れ」
  - 角度一様 + 固定振幅 → ガウス的な強弱が減る場合は、スカラー振幅のみ `standard_normal` にする。
- 直交基底の不安定化
  - `ref` の切替と EPS で安定化。`cross≈0` の場合はフォールバック基底を採用。
- 可視差の混入
  - 旧版との比較テストを seed 固定で行い、許容差（例: 端点平均距離 ≤ 1e-5）を DoD に設定。

---

## 次アクション（確認事項）

- この v2 方針（連結維持・分布互換・2パス最適化）で実装してよいか？
- 乱数のスカラー振幅をガウス化（`standard_normal`）する案は許容か？（角度は一様のまま）
- Numba 経路はオプション（存在時のみ）で良いか？
