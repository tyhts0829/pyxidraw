# displace エフェクト: amplitude_gradient 境界マイルド化 計画

## ゴール

- `effects.displace` の `amplitude_gradient` で振幅を小さくする側において、
  「ノイズ 0 の領域」と「ごく小さいノイズが乗る領域」の境界が目立ちにくくなるようにする。
- 既存の「勾配 0 で従来と完全互換」「世界座標ベースの線形モデル」という前提は維持しつつ、
  挙動をできるだけシンプルに保つ。

---

## 案 A: 最小振幅 `eps` を導入する（0 を完全に避ける）

### 方針

- 現状の線形モデル
  - `amp_axis(t) = amp_axis * max(0, 1 + k_axis * (t - 0.5))`
- を「完全 0」にならない形に変更する:
  - 例: `amp_axis(t) = amp_axis * (eps + (1 - eps) * max(0, 1 + k_axis * (t - 0.5)))`
  - `eps` は小さめの定数（候補: 0.1〜0.2）とし、ノイズが「完全に無い」領域を無くす。

### TODO: 仕様検討（要確認）

- [x] 最小振幅 `eps` の値の候補（例: 0.05 / 0.1 / 0.2）を決める。；0.1 で
- [x] `eps` を固定値とするか、将来的にパラメータ化する余地を残すかを決める（v1 では固定がシンプル）。；とりあえず固定で
- [x] `eps` の導入によって「完全にノイズを止めたい」ニーズをどこまで許容するか（= 完全 0 を捨てるか）を明文化する。；捨てる。というか、必要ならパラメータ化するから大丈夫。
- [x] 軸ごとに異なる `eps` を使う必要があるか（当面は全軸共通でよいか）を決める。；共通でいいよ。

### TODO: 実装案（displace.py）

- [ ] `_apply_noise_to_coords` 内の振幅係数計算部分を切り出し、`_compute_axis_amplitude_factor` のような小さなヘルパー関数にまとめる（Numba 対応を確認しつつ）。
- [x] 係数計算を `f_axis = max(0, 1 + k_axis * (t_axis - 0.5))` から `f_axis = eps + (1 - eps) * max(0, 1 + k_axis * (t_axis - 0.5))` に変更する。
- [x] `amplitude_mm=0` / `(0,0,0)` のときには、`eps` に関係なく即座に no-op を返す既存の分岐を維持する。
- [x] 勾配が 0 の場合は、`eps + (1 - eps) * 1 = 1` となり、従来挙動と完全に一致することを確認する。
- [x] `eps` を公開パラメータ（例: `min_gradient_factor`）として `displace` に追加し、docstring と `__param_meta__` を更新する。

### TODO: テスト / 検証

- [ ] 単純な 1 本の線について、`amplitude_gradient` の負方向勾配を大きめにしたときに、ノイズが「完全 0 になる側」が消え、滑らかに弱くなることを数値的に確認するテストを追加する。
- [x] `amplitude_gradient=0.0` のとき、既存テスト（`tests/effects/test_displace_minimal.py`）がすべて緑のままであることを確認する。
- [ ] `eps` の値を変えた場合の見え方の違いを、簡単なスケッチ（矩形やグリッド）で確認し、最終的な `eps` を決める。

---

## 案 B: 0 近傍にスムーズなイージング（smoothstep 的な関数）を入れる

### 方針

- 現状の線形係数 `f_raw = max(0, 1 + k_axis * (t_axis - 0.5))` に対して、
  - `f_axis = smoothstep(0, 1, f_raw)` のような滑らかな立ち上がり関数を噛ませる。
- これにより、「0 付近で急にノイズが ON になる」感覚を減らす。
- `smoothstep` は 0〜1 の間で C1 連続な多項式（例: `t^2 * (3 - 2t)`）とし、Numba 互換のスカラ関数にする。

### TODO: 仕様検討（要確認）

- [ ] `smoothstep` のしきい値レンジを決める（例: `f_raw` が 0〜1 の範囲に収まる想定 / あるいは 0〜f_max に正規化してから適用する）。
- [ ] `f_raw` が 1 を超える領域での扱い（そのまま使うか、1 でクリップするか）を決める。
- [ ] 「完全に 0 の領域」を残すのか、`smoothstep` でわずかにノイズを残すのか（案 A との兼ね合い）を整理する。

### TODO: 実装案（displace.py）

- [ ] `_apply_noise_to_coords` 直下に `@njit` 付きの `_smoothstep` ヘルパー（例: `t*t*(3 - 2*t)`）を追加する。
- [ ] 係数計算を `f_raw = max(0, 1 + k_axis * (t_axis - 0.5))` → `f_axis = _smoothstep(0.0, 1.0, f_raw_clamped)` のように変更する。
- [ ] `f_raw` のレンジ外（負/大きすぎ）の場合はクリップしてから `smoothstep` を適用する（例: `f_raw_clamped = min(max(f_raw, 0.0), 1.0)`）。
- [ ] `amplitude_gradient=0.0` の場合には `f_raw=1` がそのまま 1 に写ることを確認し、従来との完全互換を維持する。

### TODO: テスト / 検証

- [ ] 係数関数 `_smoothstep` 単体のテスト（0 で 0、1 で 1、中間で滑らかに増加）を追加する。
- [ ] `amplitude_gradient` の大きな負値で、ノイズの立ち上がりが「カクッ」ではなく滑らかになることを確認するテストを追加する。
- [ ] 案 A と同様、簡単なスケッチで見え方を比較し、`smoothstep` 採用の有無やパラメータを決める。

---

## 案 C: 勾配レンジを縮小 / 負側を制限する

### 方針

- 現状は `amplitude_gradient` を `[-4.0, 4.0]` にクランプしており、負側を大きくすると簡単に「完全 0 領域」が広く出る。
- このレンジを縮小したり、負側の最大値を制限することで、0 に落ち切るケースを減らし、「境界」の存在感を弱める。
- モデル自体は線形 + 0 クランプのままにし、チューニングだけでマイルドにする案。

### TODO: 仕様検討（要確認）

- [ ] 新しいクランプレンジの候補を決める（例: `[-2.0, 2.0]` や `[-1.5, 3.0]` など）。
- [ ] 正側と負側で非対称なレンジを許すか（例: 負側を弱めに、正側は現状維持）を検討する。
- [ ] Parameter GUI での RangeHint（`min/max`）をどこまでユーザーに見せるか（極端な値を UI 上からも排除するか）を決める。

### TODO: 実装案（displace.py / メタ）

- [ ] `_apply_noise_to_coords` 内の `gx, gy, gz` のソフトクランプ値を新しいレンジに変更する。
- [ ] `displace.__param_meta__["amplitude_gradient"]["min/max"]` を新しいレンジに合わせて更新する。
- [ ] `displace_amplitude_gradient_plan.md` との整合性を再確認し、記述を更新する。

### TODO: テスト / 検証

- [ ] 以前に「境界が目立つ」と感じた程度の勾配値を使ったとき、0 に落ち切る比率が減っていること（= 線全体に薄くノイズが残ること）を確認する。
- [ ] 新しいレンジの端（最小/最大）での挙動を確認し、極端な値でも破綻しないことをテストする。

---

## オープンな論点 / 次のステップ

- [ ] 上記 3 案のうち、どれを v1 の実装として採用するかを決める（単独採用 / 複数案のハイブリッドも含めて検討）。
- [ ] 「完全 0 の領域を残したい」ニーズがどの程度あるかを実際の使用感からフィードバックし、必要なら別パラメータやモード切り替えも検討する。
- [ ] 最初の実装ではもっともシンプルな案（例: 案 A または案 C）を選び、必要であれば将来のバージョンで案 B（smoothstep）的なリッチな制御を検討する。
