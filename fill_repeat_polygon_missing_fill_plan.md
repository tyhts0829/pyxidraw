# fill repeat グリッド多角形での fill 抜け改善計画

目的: `repeat` でグリッド状に回転配置した多角形に対して、`fill` エフェクトが一部ポリゴンだけ塗り線ゼロになるケースを解消する。既存の「density は全体高さベースで決まる」「共平面入力はまとめて処理する」という設計を維持しつつ、パフォーマンスをほぼ維持したまま挙動を安定化する。

対象:  
- `src/effects/fill.py`（共平面パス + スキャンライン生成ロジック）  
- 必要に応じて `src/util/geom3d_frame.py` / `src/util/polygon_grouping.py`（フレーム/グルーピング仕様の明文化のみ）  
- テスト: `tests/effects/test_fill_*`, `tests/test_effect_fill_remove_boundary.py` ほか追加テスト

---

## 現象と期待仕様の整理

- 現象（今回のスケッチ例）
  - `sketch/251117.py` のように `G.polygon(n_sides=...)` を `repeat().repeat()` でグリッド状に並べ、`affine` で回転させた後 `fill` をかけると、`n_sides` を増やしたときに一部ポリゴンで塗りがほぼ/全く生成されないことがある。
  - 対象ポリゴンは、輪郭線（boundary）はあるが内部にハッチ線が入らず、「fill が外れた」ように見える。
- 期待される挙動
  - 共平面な複数ポリゴンに対して `density` を指定した場合、**各ポリゴンごとに**「内部に少なくとも数本の塗り線が入る」ことが保証される（極端に背の低い形状を除く）。
  - グリッド配置や回転に対して、`n_sides` の変更などで「特定ポリゴンだけ塗りゼロになる」ような数値的不安定さは起きない。
  - 既存の仕様（`fill_density_tilt_bug_plan.md` で整理された density/共平面パスの方針）および実行時間オーダー（共平面パスでのバッチ処理 + Numba JIT）は維持する。

---

## 原因整理（現行実装ベース）

参考コード:
- 共平面パス: `src/effects/fill.py:60` 以降（`fill` 本体）
- スキャンライン生成: `_generate_line_fill_evenodd_multi`（同ファイル 300 行付近）
- フレーム選択: `src/util/geom3d_frame.py:15` 以降（`choose_coplanar_frame`）
- グルーピング: `src/util/polygon_grouping.py`

整理:
- 共平面パスでは `choose_coplanar_frame` により全頂点を XY 平面に整列し、全体の高さ `ref_height_global` から `_spacing_from_height(ref_height_global, density)` を計算して **単一の基準 spacing** を決めている。
- その後 `build_evenodd_groups` で「外環＋穴」のグループを作り、各グループごとに
  - グループの頂点 `g_coords` をまとめ、
  - `_generate_line_fill_evenodd_multi(g_coords, g_offsets, density, angle, spacing_override=base_spacing)` を呼んでハッチを生成する。
- `_generate_line_fill_evenodd_multi` 内では
  - グループごとの `min_y`〜`max_y` と `spacing_override` から `y_values = np.arange(min_y, max_y, spacing)` を生成し、
  - 各 y で `find_line_intersections_njit(poly, y)` により交点を求め、偶奇規則で塗り区間を作る。
- 交点判定は典型的な半開区間条件
  - `if (p1[1] <= y < p2[1]) or (p2[1] <= y < p1[1]): ...`
  で行われており、「頂点ぴったり」「水平エッジぴったり」の y は積極的には拾わない。

結果として:
- spacing は「全体高さ + density」から決まるが、`y_values` の原点はグループごとの `min_y` に依存するため、各ポリゴンは**互いにずれたスキャン格子**で評価される。
- 多角形の高さや頂点 Y 座標が少し変わると、あるポリゴンではすべてのスキャンラインが「頂点ぴったり or 輪郭ぎりぎり」を通る配置になり、半開区間条件との組み合わせで交点が十分に取れず、内部塗りがゼロになるケースが生じる。
- `n_sides` を大きくするとポリゴン高さ・頂点分布が変わり、この「悪い噛み合わせ」に落ちるグループが出現しやすくなる。

---

## 改善方針（高レベル）

1. **スキャン格子のアンカーを安定化する**
   - 「グループごとに `min_y` から始める」方式を見直し、共平面パスでは **ジオメトリ全体に対して一貫したスキャン Y グリッド** を使う。
   - 例: `global_min_y` と `base_spacing` から `y0 = global_min_y + 0.5 * base_spacing` を決め、`y_k = y0 + k * base_spacing` を全グループ共通で使用（グループ内では `min_y_group <= y_k <= max_y_group` だけ採用）。
   - これにより、グリッド配置のポリゴン全体でスキャンラインの位相が揃い、「特定のポリゴンだけ vertex にピッタリ乗り続ける」状況を減らす。

2. **スキャンライン位置に微小オフセットを導入して on-vertex ケースを避ける**
   - 半開区間条件は維持しつつ、スキャンラインの y を「ポリゴンの頂点 y と完全一致しない」ようにする小さな工夫を入れる。
   - 例: `y_k = y0 + (k + 0.5) * spacing` のように、常にセル中心を通るようにするか、`eps = ref_height_global * 1e-4` 程度の微小値を加えた `y_k = y0 + k * spacing + eps` を使う。
   - eps は height ベースで決めることでスケール不変にし、既存の見かけ密度・角度依存性にはほぼ影響を与えないようにする。

3. **「塗り線ゼロ」ポリゴンの救済パスを低コストで追加する**
   - 共平面パスの処理後に、「内部面積が十分にあるのに内部塗り線が 1 本も存在しないグループ」を検出し、軽量な救済処理を行う。
   - 救済処理は、当該グループに対してだけ
     - spacing を半分にする、あるいは y グリッドを半周期だけずらして `_generate_line_fill_evenodd_multi` を再実行し、
     - 最初の呼び出し結果とマージする。
   - グループ数・頂点数に対して救済パスは「ごく一部」に限られるため、平均性能への影響を抑えつつ、最悪ケース（塗りゼロ）を避ける。

4. **非共平面パスとの一貫性確保**
   - 非共平面パス（ポリゴン単位処理）は `_generate_line_fill` を使っており、こちらも `min_y` からの `np.arange` を使っている。
   - 必要であれば、上記 1〜2 の「アンカー + 微小オフセット」方針を `_generate_line_fill` にも部分適用し、平面・非平面間での挙動ギャップを減らす（ただし処理負荷は変えない）。

---

## チェックリスト（実装タスク）

### A. 仕様整理・設計決定

- [ ] A-1. 「各ポリゴンごとに最低何本あれば良いか」を簡易に定義する  
  - 例: `ref_height_group / base_spacing >= 1` のときは最低 1 本、`>= 3` のときは最低 2 本など、height 比に基づく緩い下限を決める。
- [ ] A-2. グローバル Y グリッドのアンカー方式を確定  
  - 候補: `global_min_y + 0.5 * base_spacing` か、`global_center_y` からの ±N ステップ。
  - `angle_sets > 1` の場合もアンカーは共通とし、角度ごとに回転のみ変える。
- [ ] A-3. 微小オフセット eps の定義とレンジを決定  
  - `eps = max(ref_height_global * k, k_min)` 形式でスケール不変 + 下限を確保（k, k_min は小さな定数）。
  - 既存テスト・スケッチで見かけ上の線位置がほとんど変わらない程度に抑える。
- [ ] A-4. 救済パスの条件とやり方を明文化  
  - 「塗り線ゼロ（or 非常に少ない）グループ」をどう判定するか（グループ内の塗り線総本数 vs 面積など）。
  - 救済時の spacing 変更 or 位相シフトのどちらを採用するか。

### B. 共平面パスのロジック変更（`fill` 本体）

- [ ] B-1. 共平面パスで `v2d_all` から `global_min_y` / `global_max_y` / `global_center_y` を計算する処理を追加  
  - `ref_height_global` は既に返っているので、それとの一貫性を保つ。
- [ ] B-2. 各グループに渡す情報を整理  
  - 現在は `_generate_line_fill_evenodd_multi` に `spacing_override` だけ渡しているが、必要に応じて  
    「グローバルアンカー y0」と「グローバル min/max」を渡せるようインターフェースを拡張する（Numba 呼び出しに影響しない形にする）。
- [ ] B-3. グループごとの呼び出しで「y グリッドを共有しつつ、グループ内の有効範囲のみ採用」するように変更  
  - 例: `_generate_line_fill_evenodd_multi` の内部で `y_values` を直接生成する代わりに、  
    「既知の y グリッド列と、グループの `min_y_group`/`max_y_group`」から有効 y をフィルタするロジックに変えるか、  
    y0 + spacing から `start_index/end_index` を計算する形にする。
- [ ] B-4. 変更後の density 振る舞いを確認  
  - 単一ポリゴン（XY 平面）のケースで `round(density)` 本前後になることを既存テスト + ad-hoc スケッチで確認。

### C. スキャンライン生成関数の更新（`_generate_line_fill_evenodd_multi` / `_generate_line_fill`）

- [ ] C-1. `y_values` 生成ロジックをアンカー + オフセット方式に差し替え  
  - `np.arange(min_y, max_y, spacing)` から、`y0 + k * spacing + eps` 形式への変更案を実装。
  - グループごとに異なる `min_y` を原点にしないようにする（または、`min_y_group` 基準でも常に 0.5 step シフト + eps をかける）。
- [ ] C-2. `find_line_intersections_njit` の半開区間条件は維持しつつ、on-vertex の影響が減ることを確認  
  - 代表的な正多角形 + 種々の回転角に対して、スキャンラインが頂点 Y のちょうど上に乗らないことを数値的にチェックする簡易テストを追加。
- [ ] C-3. 非共平面パスの `_generate_line_fill` にも同様のアンカー + オフセットを適用するか検討  
  - 適用する場合は、共平面パスと同じロジックになるよう抽象化する（重複ロジックを避ける）。

### D. 救済パス（オプションだが今回のバグ対策として有力）

- [ ] D-1. グループ単位で生成された塗り線本数を集計し、「極端に少ない/ゼロ」のグループを検出  
  - しきい値: 例として「線本数 < 1」または「line_count * spacing / ref_height_group < 某定数」。
- [ ] D-2. 該当グループに対してのみ「位相シフト or spacing 半分」の再スキャンを実装  
  - 位相シフト案: `y0_rescue = y0 + 0.5 * spacing` で `_generate_line_fill_evenodd_multi` を再呼び出し。
  - spacing 半分案: `spacing_rescue = spacing * 0.5` で再呼び出し（ただし density 値との整合を検証）。
- [ ] D-3. 再スキャン結果を既存 results とマージ  
  - 重複線があっても実害は小さいが、距離がゼロに近い重複は避けたい場合には簡単なフィルタを追加する（端点がほぼ一致する線分を除外）。
- [ ] D-4. 救済パスが走る頻度・コストを計測  
  - 代表的なスケッチ（カタログ）で「救済パスほぼゼロ、でも今回のようなグリッドケースでは効く」ことを確認。

### E. テスト・パフォーマンス検証

- [ ] E-1. 再現用テストスケッチ/ユニットテストを追加  
  - `G.polygon(n_sides=N)` を `repeat().repeat()` でグリッド配置し、`fill` 後に「各ポリゴングループに内部塗り線が少なくとも 1 本以上存在する」ことを検証するテストを書く。
  - 回転角・density・n_sides をいくつか変えたパラメトリックテストにする。
- [ ] E-2. 既存テスト群の回帰確認  
  - `pytest -q tests/test_effect_fill_remove_boundary.py`  
  - `pytest -q tests/effects/test_fill_*`  
  - 必要に応じて `pytest -q -m perf -k fill` で単体性能を確認（Ask-first 対象外範囲で）。
- [ ] E-3. カタログスケッチでの目視確認  
  - 代表的な fill 使用スケッチを数本（特に density/angle_sets/angle_rad を多用しているもの）確認し、線本数や見かけ密度が大きく変化していないことを確認。

### F. ドキュメント・アーキテクチャ更新

- [ ] F-1. `src/effects/fill.py` の docstring に「スキャン格子アンカーの方針」「on-vertex 回避のための微小オフセット」について短く追記。
- [ ] F-2. `fill_density_tilt_bug_plan.md` との整合を確認し、必要であれば「グローバル spacing の設計に on-vertex 回避を追加した」旨を補足。
- [ ] F-3. `architecture.md` の effects/fill 周りに差分があれば更新し、該当コードの参照（`src/effects/fill.py`）を明記。

---

## 事前確認したい点・オプション

- [ ] Q-1. グローバル Y グリッドのアンカー
  - 「全ポリゴン共通のグローバルアンカー」を使う案と、「グループごとに 0.5 step シフト + eps だけ適用する案」のどちらを優先したいか。
  - 見かけ密度の一貫性を重視するならグローバルアンカー、局所形状主体ならグループアンカー寄り。
- [ ] Q-2. 救済パスの有無
  - アンカー + オフセット修正だけで十分とみなすか、それでも希に塗りゼロが出ることを考慮して「ごく限定的な救済パス」を入れるか。
  - 完全なゼロ回避を優先する場合は D 系タスクを有効化したい。
- [ ] Q-3. density と線本数の関係
  - 「density=35 なら常に ~35 本前後」をどこまで重要視するか。救済パスや spacing 微調整で ±数本の揺れが出る可能性をどの程度許容して良いか。

このチェックリストで進めて問題なければ、あなたの了承後に実装に着手し、完了した項目にチェックを入れながら進捗を可視化していきます。

